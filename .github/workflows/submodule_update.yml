name: Weekly Submodule Update
on:
  schedule: # Runs at 9:00 AM UTC every Monday
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allows manual triggering
jobs:
  update-submodules:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          # Fetch all history for all tags and branches
          fetch-depth: 0
          # Fetch submodules
          submodules: 'recursive'
      - name: Set up Git user
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
      - name: Create branch for updates
        run: |
          # Create a new branch for the updates
          UPDATE_BRANCH="submodule-updates-$(date +%Y-%m-%d)"
          git checkout -b $UPDATE_BRANCH
          echo "UPDATE_BRANCH=$UPDATE_BRANCH" >> $GITHUB_ENV
      - name: Update submodules to latest releases
        run: |
          # Initialize and update all submodules
          git submodule update --init --recursive

          # Store whether any updates were made
          UPDATES_MADE=false

          # Create a detailed update report
          UPDATE_REPORT="# Submodule Updates $(date +%Y-%m-%d)\n\n"

          # For each submodule
          git submodule foreach '
            echo "Checking $name for updates..."
            UPDATE_REPORT="$UPDATE_REPORT## $name\n"

            # Save current commit and its description
            CURRENT_COMMIT=$(git rev-parse HEAD)
            CURRENT_DESC=$(git show -s --format="%h - %s" $CURRENT_COMMIT)
            UPDATE_REPORT="$UPDATE_REPORT\nCurrent version: $CURRENT_DESC\n"

            # Checkout the default branch
            git checkout $(git symbolic-ref refs/remotes/origin/HEAD | sed "s@^refs/remotes/origin/@@" || echo "master")

            # Fetch latest changes including tags
            git fetch --tags

            # Find the latest tag
            LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1` 2>/dev/null)

            if [ -n "$LATEST_TAG" ]; then
              echo "Latest release tag: $LATEST_TAG"

              # Checkout the latest tag
              git checkout $LATEST_TAG
              NEW_COMMIT=$(git rev-parse HEAD)
              NEW_DESC=$(git show -s --format="%h - %s" $NEW_COMMIT)

              # If the current commit is different from the latest tag
              if [ "$CURRENT_COMMIT" != "$NEW_COMMIT" ]; then
                echo "Updating $name to $LATEST_TAG"
                UPDATE_REPORT="$UPDATE_REPORT\nUpdated to: $NEW_DESC (tag: $LATEST_TAG)\n"
                cd $toplevel
                git add $name
                UPDATES_MADE=true
              else
                echo "$name is already at the latest release"
                UPDATE_REPORT="$UPDATE_REPORT\nAlready at latest release\n"
              fi
            else
              echo "No tags found for $name, pulling latest changes"
            fi
            UPDATE_REPORT="$UPDATE_REPORT\n"
          '

          # Set the update report as an environment variable
          echo "UPDATE_REPORT<<EOF" >> $GITHUB_ENV
          echo -e "$UPDATE_REPORT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          # Set the result as an output variable
          echo "UPDATES_MADE=$UPDATES_MADE" >> $GITHUB_ENV

          # Commit changes if updates were made
          if [ "$UPDATES_MADE" = true ]; then
            git commit -m "Weekly submodule update - $(date +%Y-%m-%d)"
            echo "Submodule updates committed to branch"
          else
            echo "All submodules are already up to date."
          fi
      - name: Push changes and create PR
        if: env.UPDATES_MADE == 'true'
        run: |
          # Push the branch to remote
          git push --set-upstream origin $UPDATE_BRANCH
      - name: Create Pull Request
        if: env.UPDATES_MADE == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: "const pr = await github.rest.pulls.create({\n  owner: context.repo.owner,\n  repo: context.repo.repo,\n  title: 'Weekly Submodule Updates - ' + new Date().toISOString().split('T')[0],\n  head: process.env.UPDATE_BRANCH,\n  base: 'master', \n  body: process.env.UPDATE_REPORT,\n  maintainer_can_modify: true\n});\n\nconsole.log(`Pull Request created: ${pr.data.html_url}`);\n\n// Add labels to the PR\nawait github.rest.issues.addLabels({\n  owner: context.repo.owner,\n  repo: context.repo.repo,\n  issue_number: pr.data.number,\n  labels: ['dependencies', 'automated-pr']\n});\n"
      - name: Create issue if update fails
        if: failure()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'Weekly submodule update failed',
              body: 'The automated weekly submodule update workflow failed. Please check the [workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.'
            })
